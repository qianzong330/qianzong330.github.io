<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Mybatis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/Mybatis/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T07:37:40.650Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-MyBatis是什么？"><a href="#1-MyBatis是什么？" class="headerlink" title="1. MyBatis是什么？"></a>1. MyBatis是什么？</h2><ul>
<li>Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，加载驱动、创建连接、创建statement等繁杂的过程，开发者开发时只需要关注如何编写SQL语句，可以严格控制sql执行性能，灵活度高。</li>
<li>作为一个半ORM框架，MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</li>
<li>由于MyBatis专注于SQL本身，灵活度高，所以比较适合对性能的要求很高，或者需求变化较多的项目，如互联网项目。</li>
</ul>
<h2 id="2-Mybaits的优缺点"><a href="#2-Mybaits的优缺点" class="headerlink" title="2. Mybaits的优缺点"></a>2. Mybaits的优缺点</h2><p>优点：</p>
<ul>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</li>
<li>能够与Spring很好的集成；</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>
</ul>
<p>缺点：</p>
<ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ul>
<h2 id="3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<h2 id="4-Hibernate-和-MyBatis-的区别"><a href="#4-Hibernate-和-MyBatis-的区别" class="headerlink" title="4. Hibernate 和 MyBatis 的区别"></a>4. Hibernate 和 MyBatis 的区别</h2><p><strong>相同点</strong>：都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p>
<p><strong>不同点</strong></p>
<p>1、映射关系</p>
<p>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单。</p>
<p>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂。</p>
<p>2、 SQL优化和移植性</p>
<p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。<br>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</p>
<p>3、开发难易程度和学习成本</p>
<p>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</p>
<p>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</p>
<p><strong>总结</strong></p>
<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>
<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p>
<h2 id="5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</p>
<p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 </p>
<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>
<p>3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。 </p>
<p>解决： Mybatis自动将java对象映射至sql语句。</p>
<p>4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。 </p>
<p>解决：Mybatis自动将sql执行结果映射至java对象。</p>
<h2 id="6-MyBatis编程步骤是什么样的？"><a href="#6-MyBatis编程步骤是什么样的？" class="headerlink" title="6. MyBatis编程步骤是什么样的？"></a>6. MyBatis编程步骤是什么样的？</h2><p>1、创建SqlSessionFactory<br>2、通过SqlSessionFactory创建SqlSession<br>3、 通过sqlsession执行数据库操作<br>4、 调用session.commit()提交事务<br>5、 调用session.close()关闭会话</p>
<h2 id="7-MyBatis与Hibernate有哪些不同？"><a href="#7-MyBatis与Hibernate有哪些不同？" class="headerlink" title="7. MyBatis与Hibernate有哪些不同？"></a>7. MyBatis与Hibernate有哪些不同？</h2><p>1、Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要 程序员自己编写 Sql 语句。 </p>
<p>2、Mybatis 直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常 适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需 求变化要求迅速输出成果。但是灵活的前提是 mybatis 无法做到数据库无关性， 如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。 </p>
<p>3、Hibernate 对象&#x2F;关系映射能力强，数据库无关性好，对于关系模型要求高的 软件，如果用 hibernate 开发可以节省很多代码，提高效率 </p>
<h2 id="8-Mybaits-的优点："><a href="#8-Mybaits-的优点：" class="headerlink" title="8. Mybaits 的优点："></a>8. Mybaits 的优点：</h2><p>1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</p>
<p>2、与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接； </p>
<p>3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。</p>
<p>4、能够与 Spring 很好的集成； 5、提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护</p>
<h2 id="9-MyBatis-框架的缺点："><a href="#9-MyBatis-框架的缺点：" class="headerlink" title="9. MyBatis 框架的缺点："></a>9. MyBatis 框架的缺点：</h2><p>1、SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。</p>
<p>2、SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<h2 id="10-和-的区别？"><a href="#10-和-的区别？" class="headerlink" title="10. #{}和${}的区别？"></a>10. #{}和${}的区别？</h2><ul>
<li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li>
<li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li>
<li>Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</li>
<li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li>
<li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li>
<li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li>
</ul>
<h2 id="11-通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？"><a href="#11-通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？" class="headerlink" title="11. 通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？"></a>11. 通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限名就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名的拼接字符串作为key值，可唯一定位一个MapperStatement。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h2 id="12-在Mapper中如何传递多个参数？"><a href="#12-在Mapper中如何传递多个参数？" class="headerlink" title="12. 在Mapper中如何传递多个参数？"></a>12. 在Mapper中如何传递多个参数？</h2><p>1、若Dao层函数有多个参数，那么其对应的xml中，#{0}代表接收的是Dao层中的第一个参数，#{1}代表Dao中的第二个参数，以此类推。</p>
<p>2、使用@Param注解：在Dao层的参数中前加@Param注解,注解内的参数名为传递到Mapper中的参数名。</p>
<p>3、多个参数封装成Map，以HashMap的形式传递到Mapper中。</p>
<h2 id="13-Mybatis动态sql有什么用？执行原理是什么？有哪些动态sql？"><a href="#13-Mybatis动态sql有什么用？执行原理是什么？有哪些动态sql？" class="headerlink" title="13. Mybatis动态sql有什么用？执行原理是什么？有哪些动态sql？"></a>13. Mybatis动态sql有什么用？执行原理是什么？有哪些动态sql？</h2><p>Mybatis动态sql可以在xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值完成逻辑判断，并动态拼接sql的功能。</p>
<p>Mybatis提供了9种动态sql标签：trim、where、set、foreach、if、choose、when、otherwise、bind</p>
<h2 id="14-xml映射文件中，不同的xml映射文件id是否可以重复？"><a href="#14-xml映射文件中，不同的xml映射文件id是否可以重复？" class="headerlink" title="14. xml映射文件中，不同的xml映射文件id是否可以重复？"></a>14. xml映射文件中，不同的xml映射文件id是否可以重复？</h2><p>不同的xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；</p>
<p>原因是namespace+id是作为Map&lt;String,MapperStatement&gt;的key使用的，如果没有namespace，就剩下id，那么id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也不同。</p>
<h2 id="15-Mybatis实现一对一有几种方式？具体是怎么操作的？"><a href="#15-Mybatis实现一对一有几种方式？具体是怎么操作的？" class="headerlink" title="15. Mybatis实现一对一有几种方式？具体是怎么操作的？"></a>15. Mybatis实现一对一有几种方式？具体是怎么操作的？</h2><p>有联合查询和嵌套查询两种方式。</p>
<p>联合查询是几个表联合查询，通过在resultMap里面配置association节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，再去另外一个表里面查询数据，也是通过association配置，但另外一个表的查询是通过select配置的。</p>
<h2 id="16-Mybatis实现一对多有几种方式？具体是怎么操作的？"><a href="#16-Mybatis实现一对多有几种方式？具体是怎么操作的？" class="headerlink" title="16. Mybatis实现一对多有几种方式？具体是怎么操作的？"></a>16. Mybatis实现一对多有几种方式？具体是怎么操作的？</h2><p>有联合查询和嵌套查询两种方式。</p>
<p>联合查询是几个表联合查询，只查询一次，通过在resultMap里面的collection节点配置一对多的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，再去另外一个表里面查询数据，也是通过collection，但另外一个表的查询是通过select配置的。</p>
<h2 id="17-Mybatis的一级、二级缓存"><a href="#17-Mybatis的一级、二级缓存" class="headerlink" title="17. Mybatis的一级、二级缓存"></a>17. Mybatis的一级、二级缓存</h2><p>1、 一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。<br>2、 二级缓存与一级缓存机制相同，默认也是采用PerpetualCache，HashMap存储，不同在于其存储作用域为Mapper（namespace），并且可自定义存储源，如Ehcache。默认打不开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口（可用来保存对象的状态），可在它的映射文件中配置。</p>
<p>对于缓存数据更新机制，当某一个作用域（一级缓存Session&#x2F;二级缓存Namespace）进行了增&#x2F;删&#x2F;改操作后，默认该作用域下所有select中的缓存将被clear。</p>
<h2 id="18-使用MyBatis的Mapper接口调用时有哪些要求？"><a href="#18-使用MyBatis的Mapper接口调用时有哪些要求？" class="headerlink" title="18. 使用MyBatis的Mapper接口调用时有哪些要求？"></a>18. 使用MyBatis的Mapper接口调用时有哪些要求？</h2><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同；<br>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType类型相同；<br>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；<br>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h2 id="19-Mybatis动态sql是做什么的？都有哪些动态sql？"><a href="#19-Mybatis动态sql是做什么的？都有哪些动态sql？" class="headerlink" title="19. Mybatis动态sql是做什么的？都有哪些动态sql？"></a>19. Mybatis动态sql是做什么的？都有哪些动态sql？</h2><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h2 id="20-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#20-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="20. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>20. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/Mybatis/" data-id="cl3wpioeo0004o0r4673h46co" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MQ面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/MQ%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T07:37:34.600Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么使用MQ？"><a href="#为什么使用MQ？" class="headerlink" title="为什么使用MQ？"></a>为什么使用MQ？</h2><p>使用MQ的场景很多，主要有三个：解耦、异步、削峰。</p>
<ul>
<li>解耦：假设现在，日志不光要插入到数据库里，还要在硬盘中增加文件类型的日志，同时，一些关键日志还要通过邮件的方式发送给指定的人。那么，如果按照原来的逻辑，A可能就需要在原来的代码上做扩展，除了B服务，还要加上日志文件的存储和日志邮件的发送。但是，如果你使用了MQ，那么，A服务是不需要做更改的，它还是将消息放到MQ中即可，其它的服务，无论是原来的B服务还是新增的日志文件存储服务或日志邮件发送服务，都直接从MQ中获取消息并处理即可。这就是解耦，它的好处是提高系统灵活性，扩展性。</li>
<li>异步：可以将一些非核心流程，如日志，短信，邮件等，通过MQ的方式异步去处理。这样做的好处是缩短主流程的响应时间，提升用户体验。</li>
<li>削峰：MQ的本质就是业务的排队。所以，面对突然到来的高并发，MQ也可以不用慌忙，先排好队，不要着急，一个一个来。削峰的好处就是避免高并发压垮系统的关键组件，如某个核心服务或数据库等。</li>
</ul>
<p>下面附场景解释：</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>场景：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p>
<p><img src="http://blog-img.coolsen.cn/img/727602-20200108091205317-949408193.png" alt="img"></p>
<p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p>
<p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>
<p><img src="http://blog-img.coolsen.cn/img/727602-20200108091329888-1880681145.png" alt="img"></p>
<p>总结：通过一个 MQ，Pub&#x2F;Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>场景：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>
<p><img src="http://blog-img.coolsen.cn/img/727602-20200108091632167-740723329.png" alt="img"></p>
<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>
<p>如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了。</p>
<p><img src="http://blog-img.coolsen.cn/img/727602-20200108091722601-747710174.png" alt="img"></p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>场景：每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>
<p>使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>
<p><img src="http://blog-img.coolsen.cn/img/727602-20200108091915241-1598228624.png" alt="img"></p>
<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>
<h2 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h2><p>1、 系统可用性降低</p>
<p>系统引入的外部依赖越多，越容易挂掉。</p>
<p>2、 系统复杂度提高</p>
<p>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</p>
<p>3、 一致性问题</p>
<p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这就数据不一致了。</p>
<h2 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h2><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>java</td>
<td>erlang</td>
<td>java</td>
<td>scala</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
<tr>
<td>社区活跃度</td>
<td>低</td>
<td>很高</td>
<td>一般</td>
<td>很高</td>
</tr>
</tbody></table>
<ul>
<li>中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；</li>
<li>大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，几乎是全世界这个领域的事实性规范。</li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-RabbitMQ是什么？"><a href="#1-RabbitMQ是什么？" class="headerlink" title="1. RabbitMQ是什么？"></a>1. RabbitMQ是什么？</h2><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。</p>
<h2 id="2-RabbitMQ特点"><a href="#2-RabbitMQ特点" class="headerlink" title="2. RabbitMQ特点?"></a>2. RabbitMQ特点?</h2><p>可靠性: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</p>
<p>灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</p>
<p>扩展性: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</p>
<p>高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</p>
<p>多种协议: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。</p>
<p>多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</p>
<p>管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</p>
<p>令插件机制: RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</p>
<h2 id="3-AMQP是什么"><a href="#3-AMQP是什么" class="headerlink" title="3. AMQP是什么?"></a>3. AMQP是什么?</h2><p>RabbitMQ就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p>
<p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>
<h2 id="4-AMQP的3层协议？"><a href="#4-AMQP的3层协议？" class="headerlink" title="4. AMQP的3层协议？"></a>4. AMQP的3层协议？</h2><p>Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</p>
<p>Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</p>
<p>TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</p>
<h2 id="5-说说Broker服务节点、Queue队列、Exchange交换器？"><a href="#5-说说Broker服务节点、Queue队列、Exchange交换器？" class="headerlink" title="5. 说说Broker服务节点、Queue队列、Exchange交换器？"></a>5. 说说Broker服务节点、Queue队列、Exchange交换器？</h2><ul>
<li>Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。</li>
<li>Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>
<li>Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>
</ul>
<h2 id="6-如何保证消息的可靠性？"><a href="#6-如何保证消息的可靠性？" class="headerlink" title="6. 如何保证消息的可靠性？"></a>6. 如何保证消息的可靠性？</h2><p>分三点：</p>
<ul>
<li>生产者到RabbitMQ：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li>
<li>RabbitMQ自身：持久化、集群、普通模式、镜像模式。</li>
<li>RabbitMQ到消费者：basicAck机制、死信队列、消息补偿机制。</li>
</ul>
<h2 id="7-生产者消息运转的流程？"><a href="#7-生产者消息运转的流程？" class="headerlink" title="7. 生产者消息运转的流程？"></a>7. 生产者消息运转的流程？</h2><ol>
<li><p><code>Producer</code>先连接到Broker,建立连接Connection,开启一个信道(Channel)。</p>
</li>
<li><p><code>Producer</code>声明一个交换器并设置好相关属性。</p>
</li>
<li><p><code>Producer</code>声明一个队列并设置好相关属性。</p>
</li>
<li><p><code>Producer</code>通过路由键将交换器和队列绑定起来。</p>
</li>
<li><p><code>Producer</code>发送消息到<code>Broker</code>,其中包含路由键、交换器等信息。</p>
</li>
<li><p>相应的交换器根据接收到的路由键查找匹配的队列。</p>
</li>
<li><p>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。</p>
</li>
<li><p>关闭信道。</p>
</li>
<li><p>管理连接。</p>
</li>
</ol>
<h2 id="8-消费者接收消息过程？"><a href="#8-消费者接收消息过程？" class="headerlink" title="8.消费者接收消息过程？"></a>8.消费者接收消息过程？</h2><ol>
<li><p><code>Producer</code>先连接到<code>Broker</code>,建立连接<code>Connection</code>,开启一个信道(<code>Channel</code>)。</p>
</li>
<li><p>向<code>Broker</code>请求消费响应的队列中消息，可能会设置响应的回调函数。</p>
</li>
<li><p>等待<code>Broker</code>回应并投递相应队列中的消息，接收消息。</p>
</li>
<li><p>消费者确认收到的消息,<code>ack</code>。</p>
</li>
<li><p><code>RabbitMq</code>从队列中删除已经确定的消息。</p>
</li>
<li><p>关闭信道。</p>
</li>
<li><p>关闭连接。</p>
</li>
</ol>
<h2 id="9-生产者如何将消息可靠投递到RabbitMQ？"><a href="#9-生产者如何将消息可靠投递到RabbitMQ？" class="headerlink" title="9. 生产者如何将消息可靠投递到RabbitMQ？"></a>9. 生产者如何将消息可靠投递到RabbitMQ？</h2><ol>
<li><p>Client发送消息给MQ</p>
</li>
<li><p>MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；</p>
</li>
<li><p>Client收到Ack消息后，认为消息已经投递成功。</p>
</li>
</ol>
<h2 id="10-RabbitMQ如何将消息可靠投递到消费者？"><a href="#10-RabbitMQ如何将消息可靠投递到消费者？" class="headerlink" title="10. RabbitMQ如何将消息可靠投递到消费者？"></a>10. RabbitMQ如何将消息可靠投递到消费者？</h2><ol>
<li><p>MQ将消息push给Client（或Client来pull消息）</p>
</li>
<li><p>Client得到消息并做完业务逻辑</p>
</li>
<li><p>Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题；</p>
</li>
<li><p>MQ将已消费的消息删除。</p>
</li>
</ol>
<h2 id="11-如何保证RabbitMQ消息队列的高可用"><a href="#11-如何保证RabbitMQ消息队列的高可用" class="headerlink" title="11. 如何保证RabbitMQ消息队列的高可用?"></a>11. 如何保证RabbitMQ消息队列的高可用?</h2><p>RabbitMQ 有三种模式：<code>单机模式</code>，<code>普通集群模式</code>，<code>镜像集群模式</code>。</p>
<p><strong>单机模式</strong>：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式</p>
<p><strong>普通集群模式</strong>：意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。</p>
<p><strong>镜像集群模式</strong>：这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据(元数据指RabbitMQ的配置数据)还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="1-RocketMQ是什么？"><a href="#1-RocketMQ是什么？" class="headerlink" title="1. RocketMQ是什么？"></a>1. RocketMQ是什么？</h2><p>RocketMQ 是阿里巴巴开源的分布式消息中间件。支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。它里面有几个区别于标准消息中件间的概念，如Group、Topic、Queue等。系统组成则由Producer、Consumer、Broker、NameServer等。</p>
<p><strong>RocketMQ 特点</strong></p>
<ul>
<li>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点</li>
<li>Producer、Consumer、队列都可以分布式</li>
<li>Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合</li>
<li>能够保证严格的消息顺序</li>
<li>支持拉（pull）和推（push）两种消息模式</li>
<li>高效的订阅者水平扩展能力</li>
<li>实时的消息订阅机制</li>
<li>亿级消息堆积能力</li>
<li>支持多种消息协议，如 JMS、OpenMessaging 等</li>
<li>较少的依赖</li>
</ul>
<h2 id="2-RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#2-RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="2. RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>2. RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h2><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Nameserver</td>
<td>无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，负责发消息到Broker。</td>
</tr>
<tr>
<td>Broker</td>
<td>就是MQ本身，负责收发消息、持久化消息等。</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</td>
</tr>
</tbody></table>
<h2 id="3-RocketMQ消费模式有几种？"><a href="#3-RocketMQ消费模式有几种？" class="headerlink" title="3. RocketMQ消费模式有几种？"></a>3. RocketMQ消费模式有几种？</h2><p>消费模型由Consumer决定，消费维度为Topic。</p>
<p>1、集群消费</p>
<ul>
<li><p>一条消息只会被同Group中的一个Consumer消费</p>
</li>
<li><p>多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据</p>
</li>
</ul>
<p>2、广播消费</p>
<p>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p>
<h2 id="4-RocketMQ消费消息是push还是pull？"><a href="#4-RocketMQ消费消息是push还是pull？" class="headerlink" title="4. RocketMQ消费消息是push还是pull？"></a>4. RocketMQ消费消息是push还是pull？</h2><p>RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是<strong>长轮询机制</strong>，即拉取方式</p>
<blockquote>
<p>broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</p>
</blockquote>
<h3 id="追问：为什么要主动拉取消息而不使用事件监听方式？"><a href="#追问：为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="追问：为什么要主动拉取消息而不使用事件监听方式？"></a>追问：为什么要主动拉取消息而不使用事件监听方式？</h3><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈。所以采取了pull的方式。</p>
<h2 id="5-broker如何处理拉取请求的？"><a href="#5-broker如何处理拉取请求的？" class="headerlink" title="5. broker如何处理拉取请求的？"></a>5. broker如何处理拉取请求的？</h2><p>Consumer首次请求Broker</p>
<ul>
<li><p>Broker中是否有符合条件的消息</p>
</li>
<li><p>有 </p>
</li>
<li><ul>
<li>响应Consumer</li>
<li>等待下次Consumer的请求</li>
</ul>
</li>
<li><p>没有</p>
</li>
<li><ul>
<li>DefaultMessageStore#ReputMessageService#run方法</li>
<li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li>
<li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li>
<li>当有新消息的时候返回请求</li>
<li>挂起consumer的请求，即不断开连接，也不返回数据</li>
<li>使用consumer的offset，</li>
</ul>
</li>
</ul>
<h2 id="6-如何让RocketMQ保证消息的顺序消费？"><a href="#6-如何让RocketMQ保证消息的顺序消费？" class="headerlink" title="6. 如何让RocketMQ保证消息的顺序消费？"></a>6. 如何让RocketMQ保证消息的顺序消费？</h2><p>首先多个queue只能保证单个queue里的顺序，queue是典型的FIFO，天然顺序。多个queue同时消费是无法绝对保证消息的有序性的。所以总结如下：</p>
<p>同一topic，同一个QUEUE，发消息的时候一个线程去发送消息，消费的时候 一个线程去消费一个queue里的消息。</p>
<h2 id="7-RocketMQ如何保证消息不丢失？"><a href="#7-RocketMQ如何保证消息不丢失？" class="headerlink" title="7. RocketMQ如何保证消息不丢失？"></a>7. RocketMQ如何保证消息不丢失？</h2><p>首先在如下三个部分都可能会出现丢失消息的情况：</p>
<ul>
<li>Producer端</li>
<li>Broker端</li>
<li>Consumer端</li>
</ul>
<p>1 、Producer端如何保证消息不丢失</p>
<ul>
<li><p>采取send()同步发消息，发送结果是同步感知的。</p>
</li>
<li><p>发送失败后可以重试，设置重试次数。默认3次。</p>
</li>
<li><p>集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。</p>
</li>
</ul>
<p>2、Broker端如何保证消息不丢失</p>
<ul>
<li><p>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</p>
</li>
<li><p>集群部署，主从模式，高可用。</p>
</li>
</ul>
<p>3、Consumer端如何保证消息不丢失</p>
<ul>
<li>完全消费正常后在进行手动ack确认。</li>
</ul>
<h2 id="7-rocketMQ的消息堆积如何处理？"><a href="#7-rocketMQ的消息堆积如何处理？" class="headerlink" title="7. rocketMQ的消息堆积如何处理？"></a>7. rocketMQ的消息堆积如何处理？</h2><p>首先要找到是什么原因导致的消息堆积，是Producer太多了，Consumer太少了导致的还是说其他情况，总之先定位问题。</p>
<p>然后看下消息消费速度是否正常，正常的话，可以通过上线更多consumer临时解决消息堆积问题</p>
<h3 id="追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"><a href="#追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？" class="headerlink" title="追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"></a>追问：如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？</h3><ul>
<li>准备一个临时的topic</li>
<li>queue的数量是堆积的几倍</li>
<li>queue分布到多Broker中</li>
<li>上线一台Consumer做消息的搬运工，把原来Topic中的消息挪到新的Topic里，不做业务逻辑处理，只是挪过去</li>
<li>上线N台Consumer同时消费临时Topic中的数据</li>
<li>改bug</li>
<li>恢复原来的Consumer，继续消费之前的Topic</li>
</ul>
<h3 id="追问：堆积时间过长消息超时了？"><a href="#追问：堆积时间过长消息超时了？" class="headerlink" title="追问：堆积时间过长消息超时了？"></a>追问：堆积时间过长消息超时了？</h3><p>RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时。也就是说未被消费的消息不会存在超时删除这情况。</p>
<h3 id="追问：堆积的消息会不会进死信队列？"><a href="#追问：堆积的消息会不会进死信队列？" class="headerlink" title="追问：堆积的消息会不会进死信队列？"></a>追问：堆积的消息会不会进死信队列？</h3><p>不会，消息在消费失败后会进入重试队列（%RETRY%+ConsumerGroup），18次（默认18次，网上所有文章都说是16次，无一例外。但是我没搞懂为啥是16次，这不是18个时间吗 ？）才会进入死信队列（%DLQ%+ConsumerGroup）。</p>
<h2 id="8-RocketMQ为什么自研nameserver而不用zk？"><a href="#8-RocketMQ为什么自研nameserver而不用zk？" class="headerlink" title="8. RocketMQ为什么自研nameserver而不用zk？"></a>8. RocketMQ为什么自研nameserver而不用zk？</h2><ol>
<li>RocketMQ只需要一个轻量级的维护元数据信息的组件，为此引入zk增加维护成本还强依赖另一个中间件了。</li>
<li>RocketMQ追求的是AP，而不是CP，也就是需要高可用。<ul>
<li>zk是CP，因为zk节点间通过zap协议有数据共享，每个节点数据会一致，但是zk集群当挂了一半以上的节点就没法使用了。</li>
<li>nameserver是AP，节点间不通信，这样会导致节点间数据信息会发生短暂的不一致，但每个broker都会定时向所有nameserver上报路由信息和心跳。当某个broker下线了，nameserver也会延时30s才知道，而且不会通知客户端（生产和消费者），只能靠客户端自己来拉，rocketMQ是靠消息重试机制解决这个问题的，所以是最终一致性。但nameserver集群只要有一个节点就可用。<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904068771479559">https://juejin.cn/post/6844904068771479559</a></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/MQ%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cl3wpiofx000do0r4gmvq4udl" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/JVM/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T07:37:22.367Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM-常考面试题"><a href="#JVM-常考面试题" class="headerlink" title="JVM 常考面试题"></a>JVM 常考面试题</h1><h2 id="1-什么是JVM内存结构？"><a href="#1-什么是JVM内存结构？" class="headerlink" title="1. 什么是JVM内存结构？"></a>1. 什么是JVM内存结构？</h2><p><img src="http://blog-img.coolsen.cn/img/image-20210220111553294.png"></p>
<p>jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区；</p>
<ul>
<li>程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；</li>
<li>虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；</li>
<li>本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；</li>
<li>堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；</li>
<li>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</li>
</ul>
<h2 id="2-什么是JVM内存模型？"><a href="#2-什么是JVM内存模型？" class="headerlink" title="2. 什么是JVM内存模型？"></a>2. 什么是JVM内存模型？</h2><p><strong>Java 内存模型</strong>（下文简称 <strong>JMM</strong>）就是在底层处理器内存模型的基础上，定义自己的多线程语义。它明确指定了一组排序规则，来保证线程间的可见性。</p>
<p>这一组规则被称为 <strong>Happens-Before</strong>, JMM 规定，要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 <strong>Happens-Before 关系</strong>：</p>
<ul>
<li><strong>单线程规则</strong>：一个线程中的每个动作都 happens-before 该线程中后续的每个动作</li>
<li><strong>监视器锁定规则</strong>：监听器的<strong>解锁</strong>动作 happens-before 后续对这个监听器的<strong>锁定</strong>动作</li>
<li><strong>volatile 变量规则</strong>：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作</li>
<li><strong>线程 start 规则</strong>：线程 <strong>start()</strong> 方法的执行 happens-before 一个启动线程内的任意动作</li>
<li><strong>线程 join 规则</strong>：一个线程内的所有动作 happens-before 任意其他线程在该线程 <strong>join()</strong> 成功返回之前</li>
<li><strong>传递性</strong>：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C</li>
</ul>
<p>怎么理解 happens-before 呢？如果按字面意思，比如第二个规则，线程（不管是不是同一个）的解锁动作发生在锁定之前？这明显不对。happens-before 也是为了保证可见性，比如那个解锁和加锁的动作，可以这样理解，线程1释放锁退出同步块，线程2加锁进入同步块，那么线程2就能看见线程1对共享对象修改的结果。</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329222941923.png"></p>
<p>Java 提供了几种语言结构，包括 <em>volatile</em>, <em>final</em> 和 <em>synchronized</em>, 它们旨在帮助程序员向<strong>编译器</strong>描述程序的并发要求，其中：</p>
<ul>
<li><strong>volatile</strong> - 保证<strong>可见性</strong>和<strong>有序性</strong></li>
<li><strong>synchronized</strong> - 保证<strong>可见性</strong>和<strong>有序性</strong>; 通过**管程（Monitor）*<em>保证一组动作的*<em>原子性</em></em></li>
<li><strong>final</strong> - 通过禁止<strong>在构造函数初始化</strong>和<strong>给 final 字段赋值</strong>这两个动作的重排序，保证<strong>可见性</strong>（如果 <strong>this 引用逃逸</strong>就不好说可见性了）</li>
</ul>
<p>编译器在遇到这些关键字时，会插入相应的内存屏障，保证语义的正确性。</p>
<p>有一点需要<strong>注意</strong>的是，<strong>synchronized</strong> <strong>不保证</strong>同步块内的代码禁止重排序，因为它通过锁保证同一时刻只有<strong>一个线程</strong>访问同步块（或临界区），也就是说同步块的代码只需满足 <strong>as-if-serial</strong> 语义 - 只要单线程的执行结果不改变，可以进行重排序。</p>
<p>所以说，Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性，另外，还确保正确同步的 Java 代码可以在不同体系结构的处理器上正确运行。</p>
<h2 id="3-heap-和stack-有什么区别？"><a href="#3-heap-和stack-有什么区别？" class="headerlink" title="3. heap 和stack 有什么区别？"></a>3. heap 和stack 有什么区别？</h2><p><strong>（1</strong>）申请方式</p>
<p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间</p>
<p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟</p>
<p><strong>（2</strong>）申请后系统的响应</p>
<p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p><strong>（3</strong>）申请大小的限制</p>
<p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。</p>
<p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。</p>
<p><strong>（4</strong>）申请效率的比较</p>
<p>stack：由系统自动分配，速度较快。但程序员是无法控制的。</p>
<p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</p>
<p><strong>（5</strong>）heap和stack中的存储内容</p>
<p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>
<h2 id="4-什么情况下会发生栈内存溢出？"><a href="#4-什么情况下会发生栈内存溢出？" class="headerlink" title="4. 什么情况下会发生栈内存溢出？"></a>4. 什么情况下会发生栈内存溢出？</h2><p>1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；<br>2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；<br>3、调整参数-xss去调整jvm栈的大小</p>
<h2 id="5-谈谈对-OOM-的认识？如何排查-OOM-的问题？"><a href="#5-谈谈对-OOM-的认识？如何排查-OOM-的问题？" class="headerlink" title="5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？"></a>5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？</h2><p>除了程序计数器，其他内存区域都有 OOM 的风险。</p>
<ul>
<li>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM</li>
<li>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；</li>
<li>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错；</li>
<li>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等；</li>
<li>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。</li>
</ul>
<p>排查 OOM 的方法：</p>
<ul>
<li>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;tmp&#x2F;heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</li>
<li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；</li>
<li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</li>
</ul>
<h2 id="6-谈谈-JVM-中的常量池？"><a href="#6-谈谈-JVM-中的常量池？" class="headerlink" title="6. 谈谈 JVM 中的常量池？"></a>6. 谈谈 JVM 中的常量池？</h2><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。</p>
<ul>
<li><strong>Class文件常量池</strong>。class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。</li>
<li><strong>运行时常量池</strong>：运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</li>
<li><strong>全局字符串常量池</strong>：字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。 </li>
<li>基本类型包装类对象常量池：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。</li>
</ul>
<h2 id="7-如何判断一个对象是否存活？"><a href="#7-如何判断一个对象是否存活？" class="headerlink" title="7. 如何判断一个对象是否存活？"></a>7. 如何判断一个对象是否存活？</h2><p>判断一个对象是否存活，分为两种算法1：引用计数法；2：可达性分析算法；</p>
<p><strong>引用计数法</strong>：<br>给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收；<br>缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；</p>
<p><strong>可达性分析法</strong><br>从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区类静态属性引用的变量</li>
<li>方法区常量池引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
</ul>
<p>但一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；第一次标记：判断当前对象是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则进行第二次标记；第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃；如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；</p>
<h2 id="8-强引用、软引用、弱引用、虚引用是什么，有什么区别？"><a href="#8-强引用、软引用、弱引用、虚引用是什么，有什么区别？" class="headerlink" title="8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？"></a>8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><ul>
<li>强引用，就是普通的对象引用关系，如 String s &#x3D; new String(“ConstXiong”)</li>
<li>软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现</li>
<li>弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现</li>
<li>虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。PhantomReference 实现</li>
</ul>
<h2 id="9-被引用的对象就一定能存活吗？"><a href="#9-被引用的对象就一定能存活吗？" class="headerlink" title="9. 被引用的对象就一定能存活吗？"></a>9. 被引用的对象就一定能存活吗？</h2><blockquote>
<p>不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。</p>
</blockquote>
<h2 id="10-Java中的垃圾回收算法有哪些？"><a href="#10-Java中的垃圾回收算法有哪些？" class="headerlink" title="10. Java中的垃圾回收算法有哪些？"></a>10. Java中的垃圾回收算法有哪些？</h2><p>java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法；<br><strong>标记清除法</strong>：<br>第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；<br>第二步：在遍历一遍，将所有标记的对象回收掉；<br>特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210220111918592.png"></p>
<p><strong>标记整理法</strong>：<br>第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；<br>第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉；<br>特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210220111933505.png"></p>
<p><strong>复制算法</strong>：<br>将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除；<br>特点：不会产生空间碎片；内存使用率极低；</p>
<p><strong>分代收集算法</strong>：<br>根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；</p>
<p><strong>对比</strong></p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329224002527.png" alt="image-20210329224002527"></p>
<h2 id="11-有哪几种垃圾回收器，各自的优缺点是什么？"><a href="#11-有哪几种垃圾回收器，各自的优缺点是什么？" class="headerlink" title="11. 有哪几种垃圾回收器，各自的优缺点是什么？"></a>11. 有哪几种垃圾回收器，各自的优缺点是什么？</h2><p>垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；</p>
<ul>
<li><p>Serial:单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，是client级别的默认GC方式。</p>
</li>
<li><p>ParNew:Serial收集器的多线程版本，也需要stop the world，复制算</p>
</li>
<li><p>Parallel Scavenge:新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；</p>
</li>
<li><p>Serial Old:Serial收集器的老年代版本，单线程收集器，使用标记整理算法。</p>
</li>
<li><p>Parallel Old：是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。</p>
</li>
<li><p>CMS:是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；</p>
</li>
<li><p>G1:标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；</p>
</li>
</ul>
<p><strong>垃圾回收器间的配合使用图：</strong></p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329224424220.png"></p>
<p><strong>各个垃圾回收器对比</strong>：</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329230618579.png"></p>
<h2 id="12-详细说一下CMS的回收过程？CMS的问题是什么？"><a href="#12-详细说一下CMS的回收过程？CMS的问题是什么？" class="headerlink" title="12. 详细说一下CMS的回收过程？CMS的问题是什么？"></a>12. 详细说一下CMS的回收过程？CMS的问题是什么？</h2><p>CMS(Concurrent Mark Sweep，并发标记清除) 收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</p>
<p>从名字就可以知道，CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下四步：</p>
<ol>
<li><p>初始标记 （CMS initial mark)：主要是标记 GC Root 开始的下级（注：仅下一级）对象，这个过程会 STW，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。</p>
</li>
<li><p>并发标记 (CMS concurrent mark)：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。这个过程是多线程的，虽然耗时理论上会比较长，但是其它工作线程并不会阻塞，没有 STW。</p>
</li>
<li><p>重新标记（CMS remark）：顾名思义，就是要再标记一次。为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾。</p>
</li>
<li><p>并发清除（CMS concurrent sweep）：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。</p>
</li>
</ol>
<p><strong>CMS 的问题：</strong></p>
<p><strong>1. 并发回收导致CPU资源紧张：</strong></p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）&#x2F; 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。</p>
<p><strong>2. 无法清理浮动垃圾：</strong></p>
<p>在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。</p>
<p><strong>3. 并发失败（Concurrent Mode Failure）：</strong></p>
<p>由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX**:** CMSInitiatingOccupancyFraction 参数来设置。</p>
<p>这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。</p>
<p><strong>4.内存碎片问题：</strong></p>
<p>CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。</p>
<p>为了解决这个问题，CMS收集器提供了一个 -XX**:<strong>+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX</strong>:**CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。</p>
<h2 id="13-详细说一下G1的回收过程？"><a href="#13-详细说一下G1的回收过程？" class="headerlink" title="13. 详细说一下G1的回收过程？"></a>13. 详细说一下G1的回收过程？</h2><p>G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理 算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制 算法实现的。</p>
<p><strong>G1 回收过程</strong>，G1 回收器的运作过程大致可分为四个步骤：</p>
<ol>
<li><p>初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p>
</li>
<li><p>并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。</p>
</li>
<li><p>最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。</p>
</li>
<li><p>清理阶段（会STW）：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。</p>
</li>
</ol>
<h2 id="14-JVM中一次完整的GC是什么样子的？"><a href="#14-JVM中一次完整的GC是什么样子的？" class="headerlink" title="14.  JVM中一次完整的GC是什么样子的？"></a>14.  JVM中一次完整的GC是什么样子的？</h2><p>先描述一下Java堆内存划分。</p>
<p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 1&#x2F;3，老年代默认占 2&#x2F;3。<br>新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。</p>
<p>新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。</p>
<p>老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329225348086.png"></p>
<p>再描述它们之间转化流程：</p>
<ul>
<li><p>对象优先在Eden分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<ul>
<li>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；</li>
</ul>
<ul>
<li>Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区；</li>
<li>移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。GC年龄的阀值可以通过参数 -XX:MaxTenuringThreshold 设置，默认为 15；</li>
<li>动态对象年龄判定：Survivor 区相同年龄所有对象大小的总和 &gt; (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%；</li>
<li>Survivor 区内存不足会发生担保分配，超过指定大小的对象可以直接进入老年代。</li>
</ul>
</li>
<li><p>大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
</li>
<li><p>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和老年代</strong>。</p>
</li>
</ul>
<h2 id="15-Minor-GC-和-Full-GC-有什么不同呢？"><a href="#15-Minor-GC-和-Full-GC-有什么不同呢？" class="headerlink" title="15. Minor GC 和 Full GC 有什么不同呢？"></a>15. Minor GC 和 Full GC 有什么不同呢？</h2><p>Minor GC：只收集新生代的GC。</p>
<p>Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式。</p>
<p><strong>Minor GC触发条件：</strong>当Eden区满时，触发Minor GC。</p>
<p><strong>Full GC触发条件</strong>：</p>
<ul>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。</li>
<li>老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）。</li>
<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>
<li>调用System.gc时，系统建议执行Full GC，但是不必然执行。</li>
</ul>
<h2 id="16-介绍下空间分配担保原则？"><a href="#16-介绍下空间分配担保原则？" class="headerlink" title="16. 介绍下空间分配担保原则？"></a>16. 介绍下空间分配担保原则？</h2><p>如果YougGC时新生代有大量对象存活下来，而 survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。</p>
<p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。</p>
<p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：</p>
<ul>
<li>① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中</li>
<li>② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。</li>
<li>③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。</li>
</ul>
<p>通过下图来了解空间分配担保原则：</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329230240201.png"></p>
<h2 id="17-什么是类加载？类加载的过程？"><a href="#17-什么是类加载？类加载的过程？" class="headerlink" title="17. 什么是类加载？类加载的过程？"></a>17. 什么是类加载？类加载的过程？</h2><p>虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象；</p>
<p>类的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示：</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329231258940.png" alt="image-20210329231258940"></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）</p>
<p>类加载过程如下：</p>
<ul>
<li><p>加载，加载分为三步：<br>1、通过类的全限定性类名获取该类的二进制流；<br>2、将该二进制流的静态存储结构转为方法区的运行时数据结构；<br>3、在堆中为该类生成一个class对象；</p>
</li>
<li><p>验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；</p>
</li>
<li><p>准备：为class对象的静态变量分配内存，初始化其初始值；</p>
</li>
<li><p>解析：该阶段主要完成符号引用转化成直接引用；</p>
</li>
<li><p>初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；</p>
</li>
</ul>
<h2 id="18-什么是类加载器，常见的类加载器有哪些？"><a href="#18-什么是类加载器，常见的类加载器有哪些？" class="headerlink" title="18. 什么是类加载器，常见的类加载器有哪些？"></a>18. 什么是类加载器，常见的类加载器有哪些？</h2><p>类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；类加载器分为以下四种：</p>
<ul>
<li><p>启动类加载器（BootStrapClassLoader）：用来加载java核心类库，无法被java程序直接引用；</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）：用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；</p>
</li>
<li><p>系统类加载器（AppClassLoader）：它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的；</p>
</li>
<li><p>自定义类加载器：由java语言实现，继承自ClassLoader；</p>
</li>
</ul>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329231439914.png"></p>
<h2 id="19-什么是双亲委派模型？为什么需要双亲委派模型？"><a href="#19-什么是双亲委派模型？为什么需要双亲委派模型？" class="headerlink" title="19. 什么是双亲委派模型？为什么需要双亲委派模型？"></a>19. 什么是双亲委派模型？为什么需要双亲委派模型？</h2><p>当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；</p>
<p>为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。</p>
<p>补充：<strong>那怎么打破双亲委派模型</strong>？</p>
<p>自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。</p>
<h2 id="20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？"><a href="#20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？" class="headerlink" title="20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？"></a>20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</h2><ul>
<li><p>JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。</p>
</li>
<li><p>Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。</p>
<p>tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：</p>
<ul>
<li>对于各个 <code>webapp</code>中的 <code>class</code>和 <code>lib</code>，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</li>
<li>与 <code>jvm</code>一样的安全性问题。使用单独的 <code>classloader</code>去装载 <code>tomcat</code>自身的类库，以免其他恶意或无意的破坏；</li>
<li>热部署。</li>
</ul>
<p>tomcat类加载器如下图：</p>
<p><img src="http://blog-img.coolsen.cn/img/image-20210329231930719.png"></p>
</li>
<li><p>OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。</p>
</li>
<li><p>JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。</p>
</li>
</ul>
<h2 id="21-说一下-JVM-调优的命令？"><a href="#21-说一下-JVM-调优的命令？" class="headerlink" title="21. 说一下 JVM 调优的命令？"></a>21. 说一下 JVM 调优的命令？</h2><ul>
<li>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>
<li>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>
<li>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。<br>jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</li>
<li>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</li>
<li>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。<h2 id="22-Java对象创建过程"><a href="#22-Java对象创建过程" class="headerlink" title="22. Java对象创建过程"></a>22. Java对象创建过程</h2></li>
</ul>
<ol>
<li>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</li>
<li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li>
<li>将除对象头外的对象内存空间初始化为0</li>
<li>对对象头进行必要设置<h2 id="23-JDK新特性"><a href="#23-JDK新特性" class="headerlink" title="23. JDK新特性"></a>23. JDK新特性</h2></li>
</ol>
<p><strong>JDK8</strong></p>
<p>支持 Lamda 表达式、集合的 stream 操作、提升HashMap性能</p>
<p><strong>JDK9</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream API中iterate方法的新重载方法，可以指定什么时候结束迭代</span></span><br><span class="line">IntStream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>默认G1垃圾回收器</p>
<p><strong>JDK10</strong> </p>
<p>其重点在于通过完全GC并行来改善G1最坏情况的等待时间。</p>
<p><strong>JDK11</strong></p>
<p>ZGC (并发回收的策略) 4TB</p>
<p>用于 Lambda 参数的局部变量语法</p>
<p><strong>JDK12</strong></p>
<p>Shenandoah GC (GC 算法)停顿时间和堆的大小没有任何关系，并行关注停顿响应时间。</p>
<p><strong>JDK13</strong></p>
<p>增加ZGC以将未使用的堆内存返回给操作系统，16TB</p>
<p><strong>JDK14</strong></p>
<p>删除cms垃圾回收器、弃用ParallelScavenge+SerialOldGC垃圾回收算法组合</p>
<p>将ZGC垃圾回收器应用到macOS和windows平台</p>
<h1 id="线上故障排查"><a href="#线上故障排查" class="headerlink" title="线上故障排查"></a>线上故障排查</h1><h2 id="1、硬件故障排查"><a href="#1、硬件故障排查" class="headerlink" title="1、硬件故障排查"></a>1、硬件故障排查</h2><p>如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常</p>
<p><strong>第一步是隔离</strong>，第二步是<strong>保留现场</strong>，第三步才是<strong>问题排查</strong>。</p>
<p><strong>隔离</strong></p>
<p>就是把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。</p>
<p><strong>现场保留</strong></p>
<p><strong>瞬时态和历史态</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnwy22d2j30l10cpt9d.jpg" alt="img"></p>
<p>查看比如 CPU、系统内存等，通过历史状态可以体现一个趋势性问题，而这些信息的获取一般依靠监控系统的协作。           </p>
<p><strong>保留信息</strong></p>
<p>（1）<strong>系统当前网络连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -antp &gt; $DUMP_DIR/ss.dump 2&gt;&amp;1</span><br></pre></td></tr></table></figure>


<p>使用 ss 命令而不是 netstat 的原因，是因为 netstat 在网络连接非常多的情况下，执行非常缓慢。</p>
<p>后续的处理，可通过查看各种网络连接状态的梳理，来排查 TIME_WAIT 或者 CLOSE_WAIT，或者其他连接过高的问题，非常有用。</p>
<p>（2）<strong>网络状态统计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s &gt; $DUMP_DIR/netstat-s.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -n DEV <span class="number">1</span> <span class="number">2</span> &gt; $DUMP_DIR/sar-traffic.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。</p>
<p>（3）<strong>进程资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p $PID &gt; $DUMP_DIR/lsof-$PID.dump</span><br></pre></td></tr></table></figure>


<p>通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。</p>
<p>（4）<strong>CPU 资源</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mpstat &gt; $DUMP_DIR/mpstat.dump 2&gt;&amp;1</span><br><span class="line">vmstat 1 3 &gt; $DUMP_DIR/vmstat.dump 2&gt;&amp;1</span><br><span class="line">sar -p ALL  &gt; $DUMP_DIR/sar-cpu.dump  2&gt;&amp;1</span><br><span class="line">uptime &gt; $DUMP_DIR/uptime.dump 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>主要用于输出当前系统的 CPU 和负载，便于事后排查。</p>
<p>（5）<strong>I&#x2F;O 资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x &gt; $DUMP_DIR/iostat.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>一般，以计算为主的服务节点，I&#x2F;O 资源会比较正常，但有时也会发生问题，比如<strong>日志输出过多，或者磁盘问题</strong>等。此命令可以输出每块磁盘的基本性能信息，用来排查 I&#x2F;O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。</p>
<p>（6）<strong>内存问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h &gt; $DUMP_DIR/free.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。</p>
<p>（7）<strong>其他全局</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef &gt; $DUMP_DIR/ps.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">dmesg &gt; $DUMP_DIR/dmesg.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">sysctl -a &gt; $DUMP_DIR/sysctl.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。</p>
<p>（8）<strong>进程快照</strong>，最后的遗言（jinfo）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jinfo $PID &gt; $DUMP_DIR/jinfo.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>此命令将输出 Java 的基本进程信息，包括<strong>环境变量和参数配置</strong>，可以查看是否因为一些错误的配置造成了 JVM 问题。</p>
<p><strong>（9）dump 堆信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jstat -gcutil $PID &gt; $DUMP_DIR/jstat-gcutil.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jstat -gccapacity $PID &gt; $DUMP_DIR/jstat-gccapacity.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。</p>
<p><strong>（10）堆信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jmap $PID &gt; $DUMP_DIR/jmap.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -heap $PID &gt; $DUMP_DIR/jmap-heap.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -histo $PID &gt; $DUMP_DIR/jmap-histo.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">$&#123;JDK_BIN&#125;jmap -dump:format=b,file=$DUMP_DIR/heap.bin $PID &gt; /dev/<span class="literal">null</span>  <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。</p>
<p><strong>（11）JVM 执行栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jstack $PID &gt; $DUMP_DIR/jstack.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp $PID -b -n <span class="number">1</span> -c &gt;  $DUMP_DIR/top-$PID.dump <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。</p>
<p><strong>（12）高级替补</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -<span class="number">3</span> $PID</span><br></pre></td></tr></table></figure>


<p>有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcore -o $DUMP_DIR/core $PID</span><br></pre></td></tr></table></figure>


<p>对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JDK_BIN&#125;jhsdb jmap --exe $&#123;JDK&#125;java  --core $DUMP_DIR/core --binaryheap</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>内存泄漏的现象</strong></li>
</ol>
<p>稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jhsdb jmap  --heap --pid  <span class="number">37340</span></span><br><span class="line">jhsdb jmap  --pid  <span class="number">37288</span></span><br><span class="line">jhsdb jmap  --histo --pid  <span class="number">37340</span></span><br><span class="line">jhsdb jmap  --binaryheap --pid  <span class="number">37340</span></span><br></pre></td></tr></table></figure>

<p>一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。</p>
<h2 id="2、报表异常-JVM调优"><a href="#2、报表异常-JVM调优" class="headerlink" title="2、报表异常 | JVM调优"></a>2、报表异常 | JVM调优</h2><p>有一个报表系统，频繁发生内存溢出，在高峰期间使用时，还会频繁的发生拒绝服务，由于大多数使用者是管理员角色，所以很快就反馈到研发这里。</p>
<p>业务场景是由于有些结果集的字段不是太全，因此需要对结果集合进行循环，并通过 HttpClient 调用其他服务的接口进行数据填充。使用 Guava 做了 JVM 内缓存，但是响应时间依然很长。</p>
<p>初步排查，JVM 的资源太少。接口 A 每次进行报表计算时，都要涉及几百兆的内存，而且在内存里驻留很长时间，有些计算又非常耗 CPU，特别的“吃”资源。而我们分配给 JVM 的内存只有 3 GB，在多人访问这些接口的时候，内存就不够用了，进而发生了 OOM。在这种情况下，没办法，只有升级机器。把机器配置升级到 4C8G，给 JVM 分配 6GB 的内存，这样 OOM 问题就消失了。但随之而来的是频繁的 GC 问题和超长的 GC 时间，平均 GC 时间竟然有 5 秒多。</p>
<p>进一步，由于报表系统和高并发系统不太一样，它的对象，存活时长大得多，并不能仅仅通过增加年轻代来解决；而且，如果增加了年轻代，那么必然减少了老年代的大小，由于 CMS 的碎片和浮动垃圾问题，我们可用的空间就更少了。虽然服务能够满足目前的需求，但还有一些不太确定的风险。</p>
<p>第一，了解到程序中有很多缓存数据和静态统计数据，为了减少 MinorGC 的次数，通过分析 GC 日志打印的对象年龄分布，把 MaxTenuringThreshold 参数调整到了 3（特殊场景特殊的配置）。这个参数是让年轻代的这些对象，赶紧回到老年代去，不要老呆在年轻代里。</p>
<p>第二，我们的 GC 时间比较长，就一块开了参数 CMSScavengeBeforeRemark，使得在 CMS remark 前，先执行一次 Minor GC 将新生代清掉。同时配合上个参数，其效果还是比较好的，一方面，对象很快晋升到了老年代，另一方面，年轻代的对象在这种情况下是有限的，在整个 MajorGC 中占的时间也有限。</p>
<p>第三，由于缓存的使用，有大量的弱引用，拿一次长达 10 秒的 GC 来说。我们发现在 GC 日志里，处理 weak refs 的时间较长，达到了 4.5 秒。这里可以加入参数 ParallelRefProcEnabled 来并行处理Reference，以加快处理速度，缩短耗时。</p>
<p>优化之后，效果不错，但并不是特别明显。经过评估，针对高峰时期的情况进行调研，我们决定再次提升机器性能，改用 8core16g 的机器。但是，这带来另外一个问题。</p>
<p><strong>高性能的机器带来了非常大的服务吞吐量</strong>，通过 jstat 进行监控，能够看到年轻代的分配速率明显提高，但随之而来的 MinorGC 时长却变的不可控，有时候会超过 1 秒。累积的请求造成了更加严重的后果。</p>
<p>这是由于堆空间明显加大造成的回收时间加长。为了获取较小的停顿时间，我们在堆上<strong>改用了 G1 垃圾回收器</strong>，把它的目标设定在 200ms。G1 是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的 GC 暂停目标，就能得到不错的性能。修改之后，虽然 GC 更加频繁了一些，但是停顿时间都比较小，应用的运行较为平滑。</p>
<p>到目前为止，也只是勉强顶住了已有的业务，但是，这时候领导层面又发力，<strong>要求报表系统可以支持未来两年业务10到100倍的增长</strong>，并保持其可用性，但是这个“千疮百孔”的报表系统，稍微一压测，就宕机，那如何应对十倍百倍的压力呢 ? 硬件即使可以做到动态扩容，但是毕竟也有极限。</p>
<p>使用 MAT 分析堆快照，发现很多地方可以通过代码优化，那些占用内存特别多的对象：</p>
<p>1、select * 全量排查，只允许获取必须的数据</p>
<p>2、报表系统中cache实际的命中率并不高，将Guava 的 Cache 引用级别改成弱引用（WeakKeys）</p>
<p>3、限制报表导入文件大小，同时拆分用户超大范围查询导出请求。</p>
<p>每一步操作都使得JVM使用变得更加可用，一系列优化以后，机器相同压测数据性能提升了数倍。</p>
<h2 id="3、大屏异常-JUC调优"><a href="#3、大屏异常-JUC调优" class="headerlink" title="3、大屏异常 | JUC调优"></a>3、大屏异常 | JUC调优</h2><p>有些数据需要使用 HttpClient 来获取进行补全。提供数据的服务提供商有的响应时间可能会很长，也有可能会造成服务整体的阻塞。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobr4whjzwj30l1058dfx.jpg" alt="img"></p>
<p>接口 A 通过 HttpClient 访问服务 2，响应 100ms 后返回；接口 B 访问服务 3，耗时 2 秒。HttpClient 本身是有一个最大连接数限制的，如果服务 3 迟迟不返回，就会造成 HttpClient 的连接数达到上限，<strong>概括来讲，就是同一服务，由于一个耗时非常长的接口，进而引起了整体的服务不可用</strong></p>
<p>这个时候，通过 jstack 打印栈信息，会发现大多数竟然阻塞在了接口 A 上，而不是耗时更长的接口 B，这个现象起初十分具有迷惑性，不过经过分析后，我们猜想其实是因为接口 A 的速度比较快，在问题发生点进入了更多的请求，它们全部都阻塞住的同时被打印出来了。</p>
<p>为了验证这个问题，我搭建了一个demo 工程，模拟了两个使用同一个 HttpClient 的接口。fast 接口用来访问百度，很快就能返回；slow 接口访问谷歌，由于众所周知的原因，会阻塞直到超时，大约 10 s。 利用ab对两个接口进行压测，同时使用 jstack 工具 dump 堆栈。首先使用 jps 命令找到进程号，然后把结果重定向到文件（可以参考 10271.jstack 文件）。</p>
<p>过滤一下 nio 关键字，可以查看 tomcat 相关的线程，足足有 200 个，这和 Spring Boot 默认的 maxThreads 个数不谋而合。更要命的是，有大多数线程，都处于 BLOCKED 状态，说明线程等待资源超时。通过grep fast | wc -l 分析，确实200个中有150个都是blocked的fast的进程。</p>
<p>问题找到了，解决方式就顺利成章了。</p>
<p>1、fast和slow争抢连接资源，通过线程池限流或者熔断处理</p>
<p>2、有时候slow的线程也不是一直slow，所以就得加入监控</p>
<p>3、使用带countdownLaunch对线程的执行顺序逻辑进行控制</p>
<h2 id="4、接口延迟-SWAP调优"><a href="#4、接口延迟-SWAP调优" class="headerlink" title="4、接口延迟 | SWAP调优"></a><strong>4、接口延迟 | SWAP调优</strong></h2><p>有一个关于服务的某个实例，经常发生服务卡顿。由于服务的并发量是比较高的，每多停顿 1 秒钟，几万用户的请求就会感到延迟。</p>
<p>我们统计、类比了此服务其他实例的 CPU、内存、网络、I&#x2F;O 资源，区别并不是很大，所以一度怀疑是机器硬件的问题。</p>
<p>接下来我们对比了节点的 GC 日志，发现无论是 Minor GC，还是 Major GC，这个节点所花费的时间，都比其他实例长得多。</p>
<p>通过仔细观察，我们发现在 GC 发生的时候，vmstat 的 si、so 飙升的非常严重，这和其他实例有着明显的不同。</p>
<p>使用 free 命令再次确认，发现 SWAP 分区，使用的比例非常高，引起的具体原因是什么呢？</p>
<p>更详细的操作系统内存分布，从 &#x2F;proc&#x2F;meminfo 文件中可以看到具体的逻辑内存块大小，有多达 40 项的内存信息，这些信息都可以通过遍历 &#x2F;proc 目录的一些文件获取。我们注意到 slabtop 命令显示的有一些异常，dentry（目录高速缓冲）占用非常高。</p>
<p>问题最终定位到是由于某个运维工程师删除日志时，定时执行了一句命令：</p>
<p>find &#x2F; | grep “xxx.log”</p>
<p>他是想找一个叫做 要被删除 的日志文件，看看在哪台服务器上，结果，这些老服务器由于文件太多，扫描后这些文件信息都缓存到了 slab 区上。而服务器开了 swap，操作系统发现物理内存占满后，并没有立即释放 cache，导致每次 GC 都要和硬盘打一次交道。</p>
<p><strong>解决方式就是关闭 SWAP 分区。</strong></p>
<p>swap 是很多性能场景的万恶之源，建议禁用。在高并发 SWAP 绝对能让你体验到它魔鬼性的一面：进程倒是死不了了，但 GC 时间长的却让人无法忍受。</p>
<h2 id="5、内存溢出-Cache调优"><a href="#5、内存溢出-Cache调优" class="headerlink" title="5、内存溢出 | Cache调优"></a>5、<strong>内存溢出 | Cache调优</strong></h2><blockquote>
<p>有一次线上遇到故障，重新启动后，使用 jstat 命令，发现 Old 区一直在增长。我使用 jmap 命令，导出了一份线上堆栈，然后使用 MAT 进行分析，通过对 GC Roots 的分析，发现了一个非常大的 HashMap 对象，这个原本是其他同事做缓存用的，但是做了一个无界缓存，没有设置超时时间或者 LRU 策略，在使用上又没有重写key类对象的hashcode和equals方法，对象无法取出也直接造成了堆内存占用一直上升，后来，将这个缓存改成 guava 的 Cache，并设置了弱引用，故障就消失了。</p>
<p>关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p>
</blockquote>
<p>内存溢出是一个结果，而<strong>内存泄漏</strong>是一个原因。内存溢出的原因有<strong>内存空间不足、配置错误</strong>等因素。一些错误的编程方式，不再被使用的对象、没有被回收、没有及时切断与 GC Roots 的联系，这就是内存泄漏。</p>
<p>举个例子，有团队使用了 HashMap 做缓存，但是并没有设置超时时间或者 LRU 策略，造成了放入 Map 对象的数据越来越多，而产生了内存泄漏。</p>
<p>再来看一个经常发生的内存泄漏的例子，也是由于 HashMap 产生的。代码如下，由于没有重写 Key 类的 hashCode 和 equals 方法，造成了放入 HashMap 的所有对象都无法被取出来，它们和外界失联了。所以下面的代码结果是 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leak example</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapLeakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">        String title;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Key, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;1&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;2&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>即使提供了 equals 方法和 hashCode 方法，也要非常小心，尽量避免使用自定义的对象作为 Key。</p>
<p>再看一个例子，关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p>
<h2 id="6、CPU飙高-死循环"><a href="#6、CPU飙高-死循环" class="headerlink" title="6、CPU飙高 | 死循环"></a>6、CPU飙高 | 死循环</h2><p>我们有个线上应用，单节点在运行一段时间后，CPU 的使用会飙升，一旦飙升，一般怀疑某个业务逻辑的计算量太大，或者是触发了死循环（比如著名的 HashMap 高并发引起的死循环），但排查到最后其实是 GC 的问题。        </p>
<p>（1）使用 top 命令，查找到使用 CPU 最多的某个进程，记录它的 pid。使用 Shift + P 快捷键可以按 CPU 的使用率进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>


<p>（2）再次使用 top 命令，加 -H 参数，查看某个进程中使用 CPU 最多的某个线程，记录线程的 ID。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp $pid</span><br></pre></td></tr></table></figure>


<p>（3）使用 printf 函数，将十进制的 tid 转化成十六进制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf %x $tid</span><br></pre></td></tr></table></figure>


<p>（4）使用 jstack 命令，查看 Java 进程的线程栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack $pid &gt;$pid.log</span><br></pre></td></tr></table></figure>


<p>（5）使用 less 命令查看生成的文件，并查找刚才转化的十六进制 tid，找到发生问题的线程上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less $pid.log</span><br></pre></td></tr></table></figure>


<p>我们在 jstack 日志搜关键字DEAD，以及中找到了 CPU 使用最多的几个线程id。</p>
<p>可以看到问题发生的根源，是我们的堆已经满了，但是又没有发生 OOM，于是 GC 进程就一直在那里回收，回收的效果又非常一般，造成 CPU 升高应用假死。接下来的具体问题排查，就需要把内存 dump 一份下来，使用 MAT 等工具分析具体原因了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/JVM/" data-id="cl3wpiog6000no0r45cyicy9m" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-重试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/31/%E9%87%8D%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2022-05-31T02:46:39.124Z" itemprop="datePublished">2022-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/31/%E9%87%8D%E8%AF%95/">简单的重试代码实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private SendResult tryToSend(Message message) &#123;</span><br><span class="line">	SendResult sendResult = null;</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">		// 最多重试5次</span><br><span class="line">		try &#123;</span><br><span class="line">			sendResult = producer.send(message);</span><br><span class="line">			// 如果没有抛出异常，则视为发送成功,<span class="built_in">break</span>掉循环</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125; catch (Exception ex) &#123;</span><br><span class="line">			logger.error(<span class="string">&quot;Metaq message send failed, message body:&quot;</span> + message.toString(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> sendResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/31/%E9%87%8D%E8%AF%95/" data-id="cl3wpiofw000bo0r4h74d5mf2" data-title="简单的重试代码实现" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-幂等问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/30/%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-05-30T03:11:57.730Z" itemprop="datePublished">2022-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/30/%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98/">Redis专题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="redis的数据类型有哪些"><a href="#redis的数据类型有哪些" class="headerlink" title="redis的数据类型有哪些"></a>redis的数据类型有哪些</h2><p>String<br>常规的set&#x2F;get操作，value可以是String也可以是数字。<br>应用：一般做一些复杂的计数功能的缓存。<br>hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。<br>应用：单点登录，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。<br>list<br>List的数据结构<br>应用：可以做简单的消息队列的功能。另外，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。生产者和消费者的场景，LIST可以很好的完成排队，先进先出的原则。<br>set<br>因为set堆放的是一堆不重复值的集合。<br>应用：可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br>sorted set<br>sorted set多了一个权重参数score，集合中的元素能够按score进行排列。<br>应用：可以做排行榜应用，取TOP N操作。</p>
<h2 id="为什么-redis-需要把所有数据放到内存中"><a href="#为什么-redis-需要把所有数据放到内存中" class="headerlink" title="为什么 redis 需要把所有数据放到内存中"></a>为什么 redis 需要把所有数据放到内存中</h2><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h2 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h2><p>Redis是基于内存的非关系型K-V数据库，既然它是基于内存的，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>实现：<br>单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p>
<h3 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h3><p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br>AOF：Redis会将每一个收到的写命令采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认是不开启的。</p>
<h2 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>优点：适合大规模的数据恢复场景，如备份，全量复制等。</p>
<p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>优点：支持秒级持久化、兼容性好<br>缺点：文件大、恢复速度慢、对性能影响大</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6439b5cbe2b547f4b6bc7fe94d3d29ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="RDB和AOF两种持久化机制，它持久化文件加载流程"></p>
<h2 id="Redis-过期策略和内存淘汰策略"><a href="#Redis-过期策略和内存淘汰策略" class="headerlink" title="Redis 过期策略和内存淘汰策略"></a>Redis 过期策略和内存淘汰策略</h2><p>我们在set key的时候，可以给它设置一个过期时间，比如expire key 60。指定这key60s后过期，60s后，redis是如何处理的嘛？我们先来介绍几种过期策略：</p>
<h3 id="定时过期"><a href="#定时过期" class="headerlink" title="定时过期"></a>定时过期</h3><p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<h3 id="惰性过期"><a href="#惰性过期" class="headerlink" title="惰性过期"></a>惰性过期</h3><p>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<h3 id="定期过期"><a href="#定期过期" class="headerlink" title="定期过期"></a>定期过期</h3><p>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<p>假设Redis当前存放30万个key，并且都设置了过期时间，如果你每隔100ms就去检查这全部的key，CPU负载会特别高，最后可能会挂掉。<br>因此，redis采取的是定期过期，每隔100ms就随机抽取一定数量的key来检查和删除的。<br>但是呢，最后可能会有很多已经过期的key没被删除。这时候，redis采用惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且已经过期了，此时就会删除。</p>
<p>但是呀，如果定期删除漏掉了很多过期的key，然后也没走惰性删除。就会有很多过期key积在内存内存，直接会导致内存爆的。或者有些时候，业务量大起来了，redis的key被大量使用，内存直接不够了，运维小哥哥也忘记加大内存了。难道redis直接这样挂掉？不会的！Redis用8种内存淘汰策略保护自己~</p>
<h3 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h3><p>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；<br>allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。<br>volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。<br>allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；<br>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。<br>allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。<br>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；<br>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/30/%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98/" data-id="cl3wpioes0007o0r40ebx5ow6" data-title="Redis专题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Sql练习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/24/Sql%E7%BB%83%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-05-24T08:06:43.703Z" itemprop="datePublished">2022-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/24/Sql%E7%BB%83%E4%B9%A0/">Sql练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">create table Student(sid varchar(10),sname varchar(10),sage datetime,ssex nvarchar(10));</span><br><span class="line">insert into Student values(<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;赵雷&#x27;</span>,<span class="string">&#x27;1990-01-01&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;02&#x27;</span>,<span class="string">&#x27;钱电&#x27;</span>,<span class="string">&#x27;1990-12-21&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;孙风&#x27;</span>,<span class="string">&#x27;1990-05-20&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;04&#x27;</span>,<span class="string">&#x27;李云&#x27;</span>,<span class="string">&#x27;1990-08-06&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;05&#x27;</span>,<span class="string">&#x27;周梅&#x27;</span>,<span class="string">&#x27;1991-12-01&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;06&#x27;</span>,<span class="string">&#x27;吴兰&#x27;</span>,<span class="string">&#x27;1992-03-01&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;07&#x27;</span>,<span class="string">&#x27;郑⽵&#x27;</span>,<span class="string">&#x27;1989-07-01&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">insert into Student values(<span class="string">&#x27;08&#x27;</span>,<span class="string">&#x27;王菊&#x27;</span>,<span class="string">&#x27;1990-01-20&#x27;</span>,<span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">create table Course(cid varchar(10),cname varchar(10),tid varchar(10));</span><br><span class="line">insert into Course values(<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;语⽂&#x27;</span>,<span class="string">&#x27;02&#x27;</span>);</span><br><span class="line">insert into Course values(<span class="string">&#x27;02&#x27;</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="string">&#x27;01&#x27;</span>);</span><br><span class="line">insert into Course values(<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table Teacher(tid varchar(10),tname varchar(10));</span><br><span class="line">insert into Teacher values(<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">insert into Teacher values(<span class="string">&#x27;02&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">insert into Teacher values(<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table SC(sid varchar(10),cid varchar(10),score decimal(18,1));</span><br><span class="line">insert into SC values(<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;01&#x27;</span>,80);</span><br><span class="line">insert into SC values(<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;02&#x27;</span>,90);</span><br><span class="line">insert into SC values(<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,99);</span><br><span class="line">insert into SC values(<span class="string">&#x27;02&#x27;</span>,<span class="string">&#x27;01&#x27;</span>,70);</span><br><span class="line">insert into SC values(<span class="string">&#x27;02&#x27;</span>,<span class="string">&#x27;02&#x27;</span>,60);</span><br><span class="line">insert into SC values(<span class="string">&#x27;02&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,80);</span><br><span class="line">insert into SC values(<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;01&#x27;</span>,80);</span><br><span class="line">insert into SC values(<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;02&#x27;</span>,80);</span><br><span class="line">insert into SC values(<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,80);</span><br><span class="line">insert into SC values(<span class="string">&#x27;04&#x27;</span>,<span class="string">&#x27;01&#x27;</span>,50);</span><br><span class="line">insert into SC values(<span class="string">&#x27;04&#x27;</span>,<span class="string">&#x27;02&#x27;</span>,30);</span><br><span class="line">insert into SC values(<span class="string">&#x27;04&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,20);</span><br><span class="line">insert into SC values(<span class="string">&#x27;05&#x27;</span>,<span class="string">&#x27;01&#x27;</span>,76);</span><br><span class="line">insert into SC values(<span class="string">&#x27;05&#x27;</span>,<span class="string">&#x27;02&#x27;</span>,87);</span><br><span class="line">insert into SC values(<span class="string">&#x27;06&#x27;</span>,<span class="string">&#x27;01&#x27;</span>,31);</span><br><span class="line">insert into SC values(<span class="string">&#x27;06&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,34);</span><br><span class="line">insert into SC values(<span class="string">&#x27;07&#x27;</span>,<span class="string">&#x27;02&#x27;</span>,89);</span><br><span class="line">insert into SC values(<span class="string">&#x27;07&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,98);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查询“01”课程比“02”课程成绩高的所有学生的学号；"><a href="#查询“01”课程比“02”课程成绩高的所有学生的学号；" class="headerlink" title="查询“01”课程比“02”课程成绩高的所有学生的学号；"></a>查询“01”课程比“02”课程成绩高的所有学生的学号；</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select t1.sid,t1.score1,t2.score2 from </span><br><span class="line">(select </span><br><span class="line">sid,score as score1</span><br><span class="line">from SC <span class="built_in">where</span> cid=<span class="string">&#x27;01&#x27;</span>) t1</span><br><span class="line"></span><br><span class="line"><span class="built_in">join</span> </span><br><span class="line">(select </span><br><span class="line">sid,score as score2</span><br><span class="line">from SC <span class="built_in">where</span> cid = <span class="string">&#x27;02&#x27;</span>) t2  on t1.sid = t2.sid and t1.score1 &gt; t2.score2</span><br></pre></td></tr></table></figure>
<h3 id="查询平均成绩大于60分的同学的学号和平均成绩"><a href="#查询平均成绩大于60分的同学的学号和平均成绩" class="headerlink" title="查询平均成绩大于60分的同学的学号和平均成绩"></a>查询平均成绩大于60分的同学的学号和平均成绩</h3><p>select<br>sid,avg(score)<br>from SC group by sid having avg(score) &gt; 60</p>
<h3 id="查询所有同学的学号、姓名、选课数、总成绩"><a href="#查询所有同学的学号、姓名、选课数、总成绩" class="headerlink" title="查询所有同学的学号、姓名、选课数、总成绩"></a>查询所有同学的学号、姓名、选课数、总成绩</h3><p>select s.sid,s.sname,ifnull(count(cid),0),ifnull(sum(score),0)  from Student s left join SC sc on s.sid &#x3D; sc.sid  group by sid</p>
<h3 id="查询姓“李”的老师的个数"><a href="#查询姓“李”的老师的个数" class="headerlink" title="查询姓“李”的老师的个数"></a>查询姓“李”的老师的个数</h3><p>select count(sid) from Student where sname like  ‘李%’;</p>
<h3 id="查询没学过“张三”老师课的同学的学号、姓名"><a href="#查询没学过“张三”老师课的同学的学号、姓名" class="headerlink" title="查询没学过“张三”老师课的同学的学号、姓名"></a>查询没学过“张三”老师课的同学的学号、姓名</h3><p>select<br>s.sid,s.sname<br>from Student s where s.sid not in(<br>select<br>sc.sid<br>from SC sc left join Course c on sc.cid &#x3D; c.cid left join Teacher t on t.tid &#x3D; c.tid where t.tname&#x3D;’张三’);</p>
<h3 id="查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名"><a href="#查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名" class="headerlink" title="查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名"></a>查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名</h3><p>select </p>
<p>from<br>(</p>
<p>select<br>sc1.sid<br>from SC sc1 where sc1.cid&#x3D;’01’<br>join<br>SC sc2 where sc2.cid&#x3D;’02’) b;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/24/Sql%E7%BB%83%E4%B9%A0/" data-id="cl3wpioer0006o0r497iubgh3" data-title="Sql练习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis专题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/24/Redis%E4%B8%93%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-05-24T03:39:47.594Z" itemprop="datePublished">2022-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/24/Redis%E4%B8%93%E9%A2%98/">Redis专题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="redis的数据类型有哪些"><a href="#redis的数据类型有哪些" class="headerlink" title="redis的数据类型有哪些"></a>redis的数据类型有哪些</h2><p>String<br>常规的set&#x2F;get操作，value可以是String也可以是数字。<br>应用：一般做一些复杂的计数功能的缓存。<br>hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。<br>应用：单点登录，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。<br>list<br>List的数据结构<br>应用：可以做简单的消息队列的功能。另外，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。生产者和消费者的场景，LIST可以很好的完成排队，先进先出的原则。<br>set<br>因为set堆放的是一堆不重复值的集合。<br>应用：可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br>sorted set<br>sorted set多了一个权重参数score，集合中的元素能够按score进行排列。<br>应用：可以做排行榜应用，取TOP N操作。</p>
<h2 id="为什么-redis-需要把所有数据放到内存中"><a href="#为什么-redis-需要把所有数据放到内存中" class="headerlink" title="为什么 redis 需要把所有数据放到内存中"></a>为什么 redis 需要把所有数据放到内存中</h2><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h2 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h2><p>Redis是基于内存的非关系型K-V数据库，既然它是基于内存的，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>实现：<br>单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p>
<h3 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h3><p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br>AOF：Redis会将每一个收到的写命令采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认是不开启的。</p>
<h2 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>优点：适合大规模的数据恢复场景，如备份，全量复制等。</p>
<p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>优点：支持秒级持久化、兼容性好<br>缺点：文件大、恢复速度慢、对性能影响大</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6439b5cbe2b547f4b6bc7fe94d3d29ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="RDB和AOF两种持久化机制，它持久化文件加载流程"></p>
<h2 id="Redis-过期策略和内存淘汰策略"><a href="#Redis-过期策略和内存淘汰策略" class="headerlink" title="Redis 过期策略和内存淘汰策略"></a>Redis 过期策略和内存淘汰策略</h2><p>我们在set key的时候，可以给它设置一个过期时间，比如expire key 60。指定这key60s后过期，60s后，redis是如何处理的嘛？我们先来介绍几种过期策略：</p>
<h3 id="定时过期"><a href="#定时过期" class="headerlink" title="定时过期"></a>定时过期</h3><p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<h3 id="惰性过期"><a href="#惰性过期" class="headerlink" title="惰性过期"></a>惰性过期</h3><p>只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<h3 id="定期过期"><a href="#定期过期" class="headerlink" title="定期过期"></a>定期过期</h3><p>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<p>假设Redis当前存放30万个key，并且都设置了过期时间，如果你每隔100ms就去检查这全部的key，CPU负载会特别高，最后可能会挂掉。<br>因此，redis采取的是定期过期，每隔100ms就随机抽取一定数量的key来检查和删除的。<br>但是呢，最后可能会有很多已经过期的key没被删除。这时候，redis采用惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且已经过期了，此时就会删除。</p>
<p>但是呀，如果定期删除漏掉了很多过期的key，然后也没走惰性删除。就会有很多过期key积在内存内存，直接会导致内存爆的。或者有些时候，业务量大起来了，redis的key被大量使用，内存直接不够了，运维小哥哥也忘记加大内存了。难道redis直接这样挂掉？不会的！Redis用8种内存淘汰策略保护自己~</p>
<h3 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h3><p>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；<br>allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰。<br>volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。<br>allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；<br>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据；。<br>allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。<br>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰；<br>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/24/Redis%E4%B8%93%E9%A2%98/" data-id="cl3jm00000000d0r46trocncl" data-title="Redis专题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-分布式事务专题-RocketMQ事务消息" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%93%E9%A2%98-RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" class="article-date">
  <time class="dt-published" datetime="2022-05-23T06:59:18.132Z" itemprop="datePublished">2022-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%93%E9%A2%98-RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/">分布式事务专题-RocketMQ事务消息</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="什么是事务消息"><a href="#什么是事务消息" class="headerlink" title="什么是事务消息"></a>什么是事务消息</h3><p>事务消息就是将发送消息和本地数据库操作融合为同一个事务，二者要么都成功，要么都失败，不能出现一个操作成功另一操作失败的情况。<br>以用户注册成功时向用户发送欢迎邮件为例。有新用户注册时，Producer 向MQ发送新用户信息，消费者消费消息发送欢迎邮件。<br>此时 Producer 的操作可以简化为两步：① 将新用户插入到数据库  ② 发送MQ消息<br>一般情况下，我们会将发送消息的操作写在数据库的事务里，尤其是将发送消息的操作放在最后一步，这样当消息发送异常时可以回滚数据库事务。向下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void saveUser(User user)&#123;</span><br><span class="line">    // ....</span><br><span class="line">    // 将用户保存到数据库</span><br><span class="line">    // ...</span><br><span class="line">    // 发送MQ消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样看似没什么问题，如果插入数据库失败也不会发送消息，发送消息失败整个事务也会回滚。<br>但是有一种情况会导致二者不一致，就是当插入数据库成功，消息也发送成功，但是由于网络等原因，Producer超时未收到 Broker 的确认（rocketMQ 同步发送方式需要接收 Broker 的确认），此时 Producer 会抛出异常，认为消息发送失败，进而导致本地事务回滚。导致的最终结果就是消息被消费，但是数据库中却没有用户的信息。<br>这种方式还有一种缺陷，当消息发送成功后会立即被消费者消费，但是此时 Producer 本地的数据库事务可能还没有提交，即使我们将发送消息的操作放在最后一步，我们也不能保证消费者拿到消息时 Producer 的本地事务已经提交。如果消费业务依赖于 Producer 的本地事务，此时消费者就不能从数据库中获取到 Producer 保存的数据。</p>
<h3 id="RocketMQ-事务消息的原理"><a href="#RocketMQ-事务消息的原理" class="headerlink" title="RocketMQ 事务消息的原理"></a>RocketMQ 事务消息的原理</h3><p>RocketMQ 事务消息将消息的发送分解为两个阶段：<br>第一阶段：发送消息，Producer把消息发送到 Broker ，但是此时该消息还不能被投递给消费者，此时消息的状态被称为半消息（Half Message） 。<br>第二阶段：提交消息。类似于数据库事务的提交，当对半消息进行二次确认，对消息进行提交或者回滚，成功提交的消息才可以被投递给消费者，回滚的消息会被删除。<br>事务状态回查<br>一般情况下，Producer 根据本地事务的执行结果，主动对半消息发送二次确认（commit 或者 rollback），但是可能由于网络或者程序代码问题等原因 Broker 未收到二次确认的消息。此时 Broker 会主动向 Producer 发起事务状态回查，根据回查的结果决定消息的去留。<br>Tips：若未收到来自 Producer 的二次确认，Broker默认每隔 1分钟 回查一次，最多回查 15 次，若达到最大次数后仍未提交或者回滚，消息会被删除。<br>代码示例<br>以Spring Boot 整合 RocketMQ 为例，业务：新用户注册时发送MQ消息</p>
<h4 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h4><p>提供保存以及查询用户的数据库操作方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">	</span><br><span class="line">    @Transactional</span><br><span class="line">    public void addUser(User user)&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO t_user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, user.getUsername(), user.getPassword(), user.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     public User getByUsername(String username)&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM t_user WHERE username = ?&quot;</span>;</span><br><span class="line">        <span class="built_in">return</span> jdbcTemplate.queryForObject(sql, new RowMapper&lt;User&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public User mapRow(ResultSet resultSet, int i) throws SQLException &#123;</span><br><span class="line">                User user = new User();</span><br><span class="line">                user.setUsername(resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">                <span class="built_in">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="实现-RocketMQLocalTransactionListener"><a href="#实现-RocketMQLocalTransactionListener" class="headerlink" title="实现 RocketMQLocalTransactionListener"></a>实现 RocketMQLocalTransactionListener</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@RocketMQTransactionListener(txProducerGroup = <span class="string">&quot;user_tx_producer_group&quot;</span>)</span><br><span class="line">public class UserTransactionListener implements RocketMQLocalTransactionListener &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行本地事务&quot;</span>);</span><br><span class="line">        try &#123;</span><br><span class="line">            User user = (User) arg;</span><br><span class="line">            userService.addUser(user);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;本地事务执行异常, 回滚消息&quot;</span>);</span><br><span class="line">            <span class="built_in">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;本地事务执行成功, 提交消息&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始本地事务状态回查&quot;</span>);</span><br><span class="line">        RocketMQLocalTransactionState localTransactionState;</span><br><span class="line">        <span class="keyword">if</span> (userService.getByUsername(((User) msg.getPayload()).getUsername()) != null) &#123;</span><br><span class="line">            localTransactionState = RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            localTransactionState = RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;本地事务状态回查结果:&#123;&#125;&quot;</span>, localTransactionState);</span><br><span class="line">        <span class="built_in">return</span> localTransactionState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RocketMQLocalTransactionListener 接口定义了两个接口。分别是半消息发送成功后的本地事务回调方法，和事务状态回查方法。<br>其实现类要使用 @RocketMQTransactionListener 注解，并定义其 txProducerGroup 属性值，该属性值可以看作是Listener的标识，发送消息时需要指定该标识，然后才能找到对于的 RocketMQLocalTransactionListener 实现类。</p>
<h4 id="UserController-接口"><a href="#UserController-接口" class="headerlink" title="UserController 接口"></a>UserController 接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    @PostMapping(<span class="string">&quot;/add&quot;</span>)</span><br><span class="line">    public String addUser(@RequestBody User user)&#123;</span><br><span class="line">        Message&lt;User&gt; message = MessageBuilder.withPayload(user).build();</span><br><span class="line">        rocketMQTemplate.sendMessageInTransaction(<span class="string">&quot;user_tx_producer_group&quot;</span>, <span class="string">&quot;user-topic&quot;</span>, message, user);</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送事务消息使用 rocketMQTemplate.sendMessageInTransaction()方法，传递的四个参数从左至右依次为<br>① 本地事务回调的实现类标识（即UserTransactionListener上面的@RocketMQTransactionListener(txProducerGroup &#x3D; “user_tx_producer_group”)）、<br>② 消息的topic<br>③ 消息体<br>④ 额外参数，回调本地事务时会传递该参数。即executeLocalTransaction(Message msg, Object arg)方法的第二个参数。<br>使用postman调用用户接口</p>
<h4 id="事务状态回查模拟"><a href="#事务状态回查模拟" class="headerlink" title="事务状态回查模拟"></a>事务状态回查模拟</h4><p>我们先在执行本地事务时打上断点，在返回事务状态前一直阻塞Producer程序，来模拟发送二次确认失败的情况，从而触发Broker的事务状态回查。</p>
<p>使用postman调用接口，当程序执行到断点位置处时阻塞，半消息和本地事务都已执行成功但还未发送二次确认，Broker等到60s的时间间隔后就会触发事务回查。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%93%E9%A2%98-RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" data-id="cl3ie9wc100002wr4ef2i6k5h" data-title="分布式事务专题-RocketMQ事务消息" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-分布式事务专题-Seata" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%93%E9%A2%98-Seata/" class="article-date">
  <time class="dt-published" datetime="2022-05-23T05:07:12.405Z" itemprop="datePublished">2022-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%93%E9%A2%98-Seata/">分布式事务专题-Seata原理解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="seata介绍"><a href="#seata介绍" class="headerlink" title="seata介绍"></a>seata介绍</h3><p>Seata框架是一个业务层的XA（两阶段提交）解决方案。在理解Seata分布式事务机制前，我们先回顾一下数据库层面的XA方案。</p>
<h3 id="MySQL-XA方案"><a href="#MySQL-XA方案" class="headerlink" title="MySQL XA方案"></a>MySQL XA方案</h3><p>MySQL从5.7开始加入了分布式事务的支持。MySQL XA中拥有两种角色：</p>
<p>RM（Resource Manager）：用于直接执行本地事务的提交和回滚。在分布式集群中，一台MySQL服务器就是一个RM。<br>TM（Transaction Manager）：TM是分布式事务的核心管理者。事务管理器与每个RM进行通信，协调并完成分布式事务的处理。发起一个分布式事务的MySQL客户端就是一个TM。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>XA的两阶段提交分为Prepare阶段和Commit阶段，过程如下：</p>
<p>阶段一为准备（prepare）阶段。即所有的RM锁住需要的资源，在本地执行这个事务（执行sql，写redo&#x2F;undo log等），但不提交，然后向Transaction Manager报告已准备就绪。<br>阶段二为提交阶段（commit）。当Transaction Manager确认所有参与者都ready后，向所有参与者发送commit命令。</p>
<p>MySQL XA拥有严重的性能问题。一个数据库的事务和多个数据库间的XA事务性能对比可发现，性能差10倍左右。另外，XA过程中会长时间的占用资源（加锁）直到两阶段提交完成才释放资源。</p>
<h3 id="seata方案"><a href="#seata方案" class="headerlink" title="seata方案"></a>seata方案</h3><p>Seata的分布式事务解决方案是业务层面的解决方案，只依赖于单台数据库的事务能力。Seata框架中一个分布式事务包含3中角色：</p>
<p>Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。<br>Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。<br>Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。<br>其中，TM是一个分布式事务的发起者和终结者，TC负责维护分布式事务的运行状态，而RM则负责本地事务的运行。</p>
<h4 id="seata执行流程"><a href="#seata执行流程" class="headerlink" title="seata执行流程"></a>seata执行流程</h4><p>1.TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。<br>2.XID 在微服务调用链路的上下文中传播。<br>3.RM 向 TC 注册分支事务，接着执行这个分支事务并提交（重点：RM在第一阶段就已经执行了本地事务的提交&#x2F;回滚），最后将执行结果汇报给TC。<br>4.TM 根据 TC 中所有的分支事务的执行情况，发起全局提交或回滚决议。<br>5.TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</p>
<h4 id="为什么Seata在第一阶段就直接提交了分支事务"><a href="#为什么Seata在第一阶段就直接提交了分支事务" class="headerlink" title="为什么Seata在第一阶段就直接提交了分支事务"></a>为什么Seata在第一阶段就直接提交了分支事务</h4><p>Seata能够在第一阶段直接提交事务，是因为Seata框架为每一个RM维护了一张UNDO_LOG表（这张表需要客户端自行创建），其中保存了每一次本地事务的回滚数据。因此，二阶段的回滚并不依赖于本地数据库事务的回滚，而是RM直接读取这张UNDO_LOG表，并将数据库中的数据更新为UNDO_LOG中存储的历史数据。</p>
<p>如果第二阶段是提交命令，那么RM事实上并不会对数据进行提交（因为一阶段已经提交了），而实发起一个异步请求删除UNDO_LOG中关于本事务的记录。</p>
<h3 id="seata详细的执行流程"><a href="#seata详细的执行流程" class="headerlink" title="seata详细的执行流程"></a>seata详细的执行流程</h3><p>1.首先TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</p>
<p>2.XID 在微服务调用链路的上下文中传播。</p>
<p>3.RM 开始执行这个分支事务，RM首先解析这条SQL语句，生成对应的UNDO_LOG记录。下面是一条UNDO_LOG中的记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;branchId&quot;</span>: 641789253,</span><br><span class="line">    <span class="string">&quot;undoItems&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;afterImage&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">                <span class="string">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: 4,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: 1</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: 12,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;GTS&quot;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: 12,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;2014&quot;</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;],</span><br><span class="line">            <span class="string">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;beforeImage&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">                <span class="string">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: 4,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: 1</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: 12,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;TXC&quot;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: 12,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;2014&quot;</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;],</span><br><span class="line">            <span class="string">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sqlType&quot;</span>: <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;xid&quot;</span>: <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，UNDO_LOG表中记录了分支ID，全局事务ID，以及事务执行的redo和undo数据以供二阶段恢复。</p>
<p>4.RM在同一个本地事务中执行业务SQL和UNDO_LOG数据的插入。在提交这个本地事务前，RM会向TC申请关于这条记录的全局锁。如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向TC汇报本地事务执行失败<br>5.RM在事务提交前，申请到了相关记录的全局锁，因此直接提交本地事务，并向TC汇报本地事务执行成功。此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。</p>
<p>6.TC根据所有的分支事务执行结果，向RM下发提交或回滚命令。</p>
<p>7.RM如果收到TC的提交命令，首先立即释放相关记录的全局锁，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。</p>
<p>8.RM如果收到TC的回滚命令，则会开启一个本地事务，通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。将 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。否则，根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句并执行，然后提交本地事务达到回滚的目的，最后释放相关记录的全局锁。</p>
<h3 id="XA和Seata-AT的对比"><a href="#XA和Seata-AT的对比" class="headerlink" title="XA和Seata AT的对比"></a>XA和Seata AT的对比</h3><p>XA 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身（通过提供支持 XA 的驱动程序来供应用使用）。而 Seata 的 RM 是以二方包的形式作为中间件层部署在应用程序这一侧的，不依赖与数据库本身对协议的支持，当然也不需要数据库支持 XA 协议。这点对于微服务化的架构来说是非常重要的：应用层不需要为本地事务和分布式事务两类不同场景来适配两套不同的数据库驱动。</p>
<p>另外，XA方案无论 Phase2 的决议是 commit 还是 rollback，事务性资源的锁都要保持到 Phase2 完成才释放。而对于Seata，将锁分为了本地锁和全局锁，本地锁由本地事务管理，在分支事务Phase1结束时就直接释放。而全局锁由TC管理，在决议 Phase2 全局提交时，全局锁马上可以释放。只有在决议全局回滚的情况下，全局锁 才被持有至分支的 Phase2 结束。因此，Seata对于资源的占用时间要少的多</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%93%E9%A2%98-Seata/" data-id="cl3idpiy30000nor40oc7axo8" data-title="分布式事务专题-Seata原理解析" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/23/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-05-23T04:31:47.840Z" itemprop="datePublished">2022-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/23/hello-world/" data-id="cl3i9bkj1000030r4bgxze7cw" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/02/Netty/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/02/Java%E9%9B%86%E5%90%88%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/02/HashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/02/HashMap/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/06/02/ConcurrentHashMap/">ConcurrentHashMap</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>